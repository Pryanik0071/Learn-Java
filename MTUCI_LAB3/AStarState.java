import java.util.*;


/**
 * Этот класс хранит базовое состояние, необходимое алгоритму A * для вычисления пути по карте.
 * Это состояние включает в себя коллекцию «открытых путевых точек» и другую коллекцию «закрытых путевых точек».
 * Кроме того, этот класс предоставляет основные операции, необходимые алгоритму поиска пути A * для его обработки.
 **/
public class AStarState {
    /** Это ссылка на карту, по которой движется алгоритм A *. **/
    private Map2D map;

    /** Инициализируйте карту всех открытых путевых точек и их местоположений. **/
    private Map<Location, Waypoint> open_waypoints
            = new HashMap<Location, Waypoint> ();

    /** Инициализируйте карту всех закрытых путевых точек и их местоположений. **/
    private Map<Location, Waypoint> closed_waypoints
            = new HashMap<Location, Waypoint> ();

    /** Инициализируйте новый объект состояния для алгоритма поиска пути A *. **/
    public AStarState(Map2D map) {
        if (map == null)
            throw new NullPointerException("map cannot be null");

        this.map = map;
    }

    /** Возвращает карту, по которой перемещается указатель пути A *. **/
    public Map2D getMap() {
        return map;
    }

    /**
     * Этот метод просматривает все открытые путевые точки и возвращает путевую точку с минимальной общей стоимостью.
     * Если открытых путевых точек нет, этот метод возвращает <code> null </ code>.
     **/
    public Waypoint getMinOpenWaypoint() {
        // Если открытых путевых точек нет, возвращает <code> null </ code>.
        if (numOpenWaypoints() == 0)
            return null;

        // Инициализируйте набор ключей всех открытых путевых точек,
        // итератор для итерации по набору и переменную для хранения
        // наилучшей путевой точки и стоимости этой путевой точки.
        Set open_waypoint_keys = open_waypoints.keySet();
        Iterator i = open_waypoint_keys.iterator();
        Waypoint best = null;
        float best_cost = Float.MAX_VALUE;

        // Сканирует все открытые путевые точки.
        while (i.hasNext()) {
            // Хранит текущее местоположение.
            Location location = (Location)i.next();
            // Сохраняет текущую путевую точку.
            Waypoint waypoint = open_waypoints.get(location);
            // Сохраняет общую стоимость для текущей путевой точки.
            float waypoint_total_cost = waypoint.getTotalCost();

            // Если общая стоимость для текущей путевой точки лучше (ниже), чем сохраненная стоимость для сохраненной
            // наилучшей путевой точки, замените сохраненную путевую точку на текущую путевую точку,
            // а сохраненную общую стоимость на текущую общую стоимость.
            if (waypoint_total_cost < best_cost) {
                best = open_waypoints.get(location);
                best_cost = waypoint_total_cost;
            }

        }
        // Возвращает путевую точку с минимальной общей стоимостью.
        return best;
    }

    /**
     * Этот метод добавляет путевую точку (или потенциально обновляет путевую точку, уже находящуюся в)
     * в коллекцию «открытых путевых точек». Если в местоположении новой путевой точки еще нет открытой путевой точки,
     * то новая путевая точка просто добавляется в коллекцию. Однако, если в местоположении новой путевой точки уже
     * есть путевая точка, новая путевая точка заменяет старую <em>, только если </ em> значение «предыдущей стоимости»
     * новой путевой точки меньше значения «предыдущей стоимости» текущей путевой точки.
     **/
    public boolean addOpenWaypoint(Waypoint newWP) {
        // Находит местоположение новой путевой точки.
        Location location = newWP.getLocation();

        // Проверяет, есть ли уже открытая путевая точка в местоположении новой путевой точки.
        if (open_waypoints.containsKey(location)) {
            // Если в местоположении новой путевой точки уже есть открытая путевая точка, проверяется,
            // меньше ли значение "предыдущей стоимости" новой путевой точки, чем значение
            // "предыдущей стоимости" текущей путевой точки.
            Waypoint current_waypoint = open_waypoints.get(location);
            if (newWP.getPreviousCost() < current_waypoint.getPreviousCost()) {
                // Если значение «предыдущей стоимости» новой путевой точки меньше значения «предыдущей стоимости»
                // текущей путевой точки, новая путевая точка заменяет старую путевую точку и возвращает значение true.
                open_waypoints.put(location, newWP);
                return true;
            }
            // Если значение «предыдущей стоимости» новой путевой точки не меньше значения «предыдущей стоимости» текущей
            // путевой точки, верните false.
            return false;
        }
        // Если в местоположении новой путевой точки еще нет открытой путевой точки, добавьте новую путевую точку
        // в коллекцию открытых путевых точек и верните true.
        open_waypoints.put(location, newWP);
        return true;
    }


    /** Возвращает текущее количество открытых путевых точек. **/
    public int numOpenWaypoints()
    {
        return open_waypoints.size();
    }

    /** Этот метод перемещает путевую точку в указанном месте из открытого списка в закрытый список. **/
    public void closeWaypoint(Location loc) {
        Waypoint waypoint = open_waypoints.remove(loc);
        closed_waypoints.put(loc, waypoint);
    }

    /** Возвращает true, если коллекция закрытых путевых точек содержит путевую точку для указанного местоположения. **/
    public boolean isLocationClosed(Location loc)
    {
        return closed_waypoints.containsKey(loc);
    }
}